function solution(x, y, r, d, target)
{
  let answer = 0;

  function vector(a, b) {
    return Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2));
  }

  function getInner(_x, _y, a, b) {
    return (_x * a) + (_y * b);
  }

  function getDistance(_x, _y) {
    return Math.sqrt(Math.pow(_x, 2) + Math.pow(_y, 2));
  }

  const uv = vector(x, y);
  for (let i = 0; i < target.length; i += 1) {
    if (getDistance(target[i][0], target[i][1]) > r) continue;

    // 타켓의 백터
    const tv = vector(target[i][0], target[i][1]);

    // 두 백터의 내적
    const inner = getInner(x, y, target[i][0], target[i][1])

    // 두 백터 간의 각도
    console.log(target[i][0], target[i][1], inner, uv * tv);
    const gap = Math.acos(inner/(uv * tv));

    if (gap <= d) {
      answer += 1;
    }
  }

  return answer;
}

console.log(solution(-1, 2, 2, 60, [[0, 1], [-1, 1], [1, 0], [-2, 2]]));


// 문제 설명
// 3개의 숫자 mod1, mod2, max_range가 주어집니다. 1 이상 max_range 이하의 자연수 중에서 mod1로 나누어떨어지지만,
// mod2로 나누어떨어지지 않는 수의 개수를 return 하도록 solution 함수를 완성하세요.
//
//   제한사항
// 1 ≤ mod1, mod2, max_range ≤ 100,000,000
// mod1, mod2, max_range 는 자연수
// 입출력 예
// mod1	mod2	max_range	result
// 4	3	20	4
// 3	4	20	5
// 입출력 예 설명
// 입출력 예 #1
// mod1 = 4, mod2 = 3, max_range = 20 일 때, 1 이상 20 이하의 자연수 중 조건에 맞는 숫자는 4, 8, 16, 20의 4개가 존재하므로 4를 return 합니다.
//
//   입출력 예 #2
// mod1 = 3, mod2 = 4, max_range = 20 일 때, 1 이상 20 이하의 자연수 중 조건에 맞는 숫자는 3, 6, 9, 15, 18의 5개가 존재하므로 5를 return 합니다.


// 문제 설명
// 아래 그림과 같이 게임 캐릭터가 사용하는 부채꼴 모양의 범위 공격 스킬의 피격 판정 기능을 만들려고 합니다.
//
//   부채꼴_g9x9v2.png
//
// 게임 캐릭터가 스킬을 사용하기 위해서는 스킬을 사용하고 싶은 위치 (x, y)를 마우스로 클릭하면 됩니다. 이때, 스킬은 마우스로 클릭한 위치를 중심으로 시계방향으로 d도, 반시계방향으로 d도 만큼의 공격 범위를 가지며, 항상 r만큼의 공격 거리를 가집니다.
//   다음은 평면 위의 캐릭터가 (0, 0) 위치에서 스킬을 사용했을 때의 상태를 나타낸 그림입니다. 그림에서 빨간색 점은 플레이어, 파란색 점은 몬스터를 나타냅니다.
//
// 360.png
//
// 위 그림에서 (-1, 2) 지점을 마우스로 클릭했을 때, 캐릭터의 스킬은 (-1, 2) 방향을 중심으로 시계방향으로 60도, 반시계방향으로 60도의 공격 범위를 가지며 2만큼의 공격 거리를 가집니다. 이때, (0, 1) 위치의 1번 몬스터와 (-1, 1) 위치의 2번 몬스터는 스킬 범위 안쪽에 있으며, (1, 0)과 (-2, 2) 위치의 3, 4번 몬스터는 스킬 범위 밖에 있습니다.
//
//   스킬을 사용하기 위해 마우스로 클릭한 위치의 좌표 x, y, 스킬의 공격 거리 r, 스킬의 공격 범위 각도 d와 몬스터들이 있는 좌표의 배열 target이 매개변수로 주어질 때, 스킬 범위 안쪽에 있는 몬스터의 수를 return 하도록 solution 함수를 완성해 주세요.
//
//   제한사항
// 캐릭터는 항상 (0, 0) 위치에서 스킬을 사용합니다.
//   마우스로 클릭한 좌표 x, y : -100 ≤ x, y ≤ 100, 단, (x, y) = (0, 0)인 경우는 주어지지 않습니다.
//   스킬의 공격 거리 r : 0 < r ≤ 100
// 스킬의 공격 범위 각도 d : 0 < d ≤ 180
// 몬스터들의 위치를 담고 있는 배열 target의 길이는 1 이상 50 이하 입니다.
//   target의 각 원소는 2개의 원소로 이루어져 있으며 순서대로 mx, my를 나타냅니다. 단, (mx, my) = (0, 0)인 경우는 주어지지 않습니다.
//   모든 값은 정수로만 주어집니다.
//   몬스터의 위치 (mx, my)가 스킬 범위 안에 있다면 (mx, my)로부터 10-6 만큼 떨어져 있는 모든 지점 (X, Y) 또한 스킬 범위 안에 속하며, 몬스터의 위치 (mx, my)가 스킬 범위 밖에 있다면 (mx, my)로부터 10-6 만큼 떨어져 있는 모든 지점 (X, Y) 또한 스킬 범위 밖에 속하는 경우만 입력으로 주어집니다.
//   입출력 예
// x	y	r	d	target	result
// -1	2	2	60	[[0, 1], [-1, 1], [1, 0], [-2, 2]]	2
// 입출력 예 설명
// 입출력 예 #1
// 문제의 예시와 같습니다. 위 그림에서 1번, 2번 몬스터는 스킬 범위 안에 있고, 3, 4번 몬스터는 밖에 있으므로 두 마리의 몬스터가 스킬 범위 안에 있습니다. 따라서 2를 return 합니다.


// 문제 설명
// 알파벳이 적힌 카드 24장이 한 줄에 8장씩, 세 줄로 놓여 있습니다. 같은 알파벳이 적힌 카드가 여러 장 있을 수 있으나, 같은 알파벳이 적힌 카드는 반드시 같은 줄에 놓여 있습니다.
//
//   예를 들어,
//
//   카드만들기1_hyuqrc.png
//
// 의 형태로 놓여있습니다.
//
//   우리는 어떤 단어들이 주어질 때, 각 단어를 주어진 카드로 만들 수 있는지 판별하려고 합니다. 단, 주어진 카드로 만들 때는 반드시 한 줄에 한 카드는 사용해야 합니다.
//
//   예를 들어, 주어진 단어가 ["GPQM", "GPMZ", "EFU", "MMNA"]인 경우
//
// "GPQM"라는 단어는
// 카드만들기2_tccpip.png
//
// 첫 번째 줄에서 'G', 두 번째 줄에서 'P'와 'Q', 세 번째 줄에서 'M'을 골라 만들 수 있습니다.
//
// "GPMZ"라는 단어는
// 카드만들기3_qmdbhc.png
//
// 'Z'가 적힌 카드가 없으므로 만들 수 없습니다.
//
// "EFU"라는 단어는
// 카드만들기4_ur0453.png
//
// 첫 번째 줄에서 'E'와 'F', 두 번째 줄에서 'U'를 고르면 완성되지만, 세 번째 줄에서 카드를 사용하지 않았기 때문에 단어를 만들 수 없습니다.
//
// "MMNA"라는 단어는
// 카드만들기5_tdssv7.png
//
// 세 번째 줄에서 'M' 2개, 두 번째 줄에서 'N', 첫 번째 줄에서 'A'를 골라 만들 수 있습니다.
//
//   알파벳이 적힌 카드 card와 만들어야 하는 단어들 word가 매개변수로 주어질 때, 만들 수 있는 단어들만 return 하는 solution 함수를 완성해 주세요. 단, 만들 수 있는 단어들을 return 할 때는 매개변수 word의 순서대로 반환하면 됩니다. 위의 예시에서는 ["GPQM", "MMNA"]로 반환하면 됩니다. 또한, 어떤 단어도 만들지 못할 때는 1차원 배열에 "-1"을 넣어 반환해 주세요.
//
//   제한사항
// card는 길이가 3인 1차원 배열입니다.
//   card의 원소는 길이 8의 string형입니다. 이 문자열은 대문자로만 이루어져 있습니다.
//   word는 1차원 배열로 주어지며, 배열의 길이는 10 이하의 자연수입니다.
//   word의 각 원소는 string형이며, 각 원소의 길이는 24 이하의 자연수입니다.
//   입출력 예
// card	word	answer
//   ["ABACDEFG", "NOPQRSTU", "HIJKLKMM"]	["GPQM", "GPMZ", "EFU", "MMNA"]	["GPQM","MMNA"]
//   ["AABBCCDD", "KKKKJJJJ", "MOMOMOMO"]	["AAAKKKKKMMMMM","ABCDKJ"]	["-1"]
// 입출력 예 설명
// 입출력 예 #1
// 문제의 예시와 같습니다.
//
//   입출력 예 #2
// 어떠한 단어도 만들지 못하기 때문에 ["-1"]를 반환합니다.

// 문제 설명
// 문자열에서 일정한 간격으로 같은 문자열이 반복해서 나타난다면 이를 문자열의 주기라고 합니다. 예를 들어 문자열 "abababab"에서 문자열의 주기는 다음과 같이 세 가지가 있습니다.
//
//   문자열 "ab"가 네 번 반복해서 나타납니다.
//   문자열 "abab"가 두 번 반복해서 나타납니다.
//   문자열 "abababab"가 한 번 반복해서 나타납니다.
//   이때, 가능한 짧은 주기를 문자열의 주기로 정합니다. 따라서 위 문자열의 주기는 2가 됩니다.
//   문자열 s가 매개변수로 주어질 때, 문자열의 주기를 return 하도록 solution 함수를 완성해주세요.
//
//   제한사항
// s는 알파벳 소문자로만 이루어진 문자열입니다.
//   s의 길이는 1 이상 1,000,000 이하입니다.
//   입출력 예
// s	result
// "abababab"	2
// "abcabcabd"	9
// 입출력 예 설명
// 입출력 예 #1
// 문제의 예시와 같습니다.
//
//   입출력 예 #2
// "abc"가 s[3]~ s[5]에서 한번 반복해서 나타나지만, s[6]~s[8]에서는 나타나지 않으므로 가장 짧은 주기는 전체 문자열의 길이인 9가 됩니다.