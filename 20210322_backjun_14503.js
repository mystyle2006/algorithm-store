//  0인 경우에는 북쪽을, 1인 경우에는 동쪽을, 2인 경우에는 남쪽을, 3인 경우에는 서쪽을 바라보고 있는 것이다.
// 북(0), 동(1), 남(2), 서(3)

const di = [3, 0, 1, 2];

const dy = [0, -1, 0, 1];
const dx = [-1, 0, 1, 0];

const by = [1, 0, -1, 0];
const bx = [0, -1, 0, 1];

//
// 0 + 3 % 4 = 3
// 1 + 3 % 4 = 0
// 2 + 3 % 4 = 1
// 3 + 3 % 4 = 2

const WALL = 1;
const EMPTY = 0;
const CLEAN = 2;

// 현재 위치를 청소한다.
//   현재 위치에서 현재 방향을 기준으로 왼쪽방향부터 차례대로 탐색을 진행한다.
//   왼쪽 방향에 아직 청소하지 않은 공간이 존재한다면, 그 방향으로 회전한 다음 한 칸을 전진하고 1번부터 진행한다.
//   왼쪽 방향에 청소할 공간이 없다면, 그 방향으로 회전하고 2번으로 돌아간다.
//   네 방향 모두 청소가 이미 되어있거나 벽인 경우에는, 바라보는 방향을 유지한 채로 한 칸 후진을 하고 2번으로 돌아간다.
//   네 방향 모두 청소가 이미 되어있거나 벽이면서, 뒤쪽 방향이 벽이라 후진도 할 수 없는 경우에는 작동을 멈춘다.

function solution(n, m, robot, board) {
  let cnt = 0;

  function dfs(r, c, d) {
    if (board[r][c] === EMPTY) {
      board[r][c] = CLEAN;
      cnt += 1;
    }

    for (let i = 1; i < (1 + 4); i += 1) {
      const index = i % 4;
      const _r = r + dy[index];
      const _c = c + dx[index];
      const _d = di[index];

      if (board[_r][_c] === EMPTY) {
        dfs(_r, _c, _d);
        return;
      }
    }

    if (board[r + by[d]][c + bx[d]] === WALL) return;
    else dfs(r + by[d],c + bx[d], d);
  }

  dfs(...robot);

  return cnt;
};

// console.log(solution(3, 3, [1, 1, 0], [
//   [1, 1, 1],
//   [1, 0, 1],
//   [1, 1, 1],
// ]));

console.log(solution(11, 10, [7, 4, 0], [
  [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
  [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
  [1, 0, 0, 0, 1, 1, 1, 1, 0, 1],
  [1, 0, 0, 1, 1, 0, 0, 0, 0, 1],
  [1, 0, 1, 1, 0, 0, 0, 0, 0, 1],
  [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
  [1, 0, 0, 0, 0, 0, 0, 1, 0, 1],
  [1, 0, 0, 0, 0, 0, 1, 1, 0, 1],
  [1, 0, 0, 0, 0, 0, 1, 1, 0, 1],
  [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
  [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
]));


